<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>janghanboram&#39;s blog</title>
  
  <subtitle>Front-End Developer blog</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://janghanboram.github.io/"/>
  <updated>2018-06-15T07:11:09.000Z</updated>
  <id>http://janghanboram.github.io/</id>
  
  <author>
    <name>Robbin Hanboram Jang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>브라우저 렌더링</title>
    <link href="http://janghanboram.github.io/2018/06/06/browser-rendering/"/>
    <id>http://janghanboram.github.io/2018/06/06/browser-rendering/</id>
    <published>2018-06-06T06:22:50.000Z</published>
    <updated>2018-06-15T07:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>웹 개발자라면, 개발한 웹페이지가 느려서, 고생한 경험이 있을 것이다. 때로는 클라이언트로서 느린 웹서비스에 불만을 가진 적도 있을 것이다. 이를 기술적으로 해결하는 방법 중 하나가, “렌더링 최적화”이다. 거창한 것이 아니고, 브라우저가 컨텐츠를 화면에 그릴 때(렌더링), 성능을 저하시키는 요소들을 개선하는 것이다. 따라서, <strong>”렌더링 최적화”를 이해하기 위해서는, “브라우저의 렌더링 과정”에 대해서 먼저 알아야 한다.</strong></p><h1 id="브라우저에-대해서"><a href="#브라우저에-대해서" class="headerlink" title="브라우저에 대해서"></a>브라우저에 대해서</h1><h2 id="1-브라우저의-역할"><a href="#1-브라우저의-역할" class="headerlink" title="1. 브라우저의 역할"></a>1. 브라우저의 역할</h2><p>사용자가 선택한 자원(URL)을 서버에 요청하고 받아 화면에서 표시한다. 조금 더 풀어서 이야기하면, 주소창에 주소를 입력한 후, 엔터를 치면 브라우저가 해당 주소로 요청을 보낸다. 이때, 요청을 받은 곳, 즉, 서버에서 응답을 보내준다. 브라우저는 요청에 대한 결과(응답)를 화면에 그린다.</p><img src="/2018/06/06/browser-rendering/client_server.png" title="description of the communication betewwen server and client"><h5 id="참고-내용"><a href="#참고-내용" class="headerlink" title="참고 내용"></a>참고 내용</h5><ul><li>더 자세한 설명이 필요하다면, “이고잉님의 서버와 클라이언트” <a href="https://www.youtube.com/watch?v=YfXj8kOo7j4" rel="external nofollow noopener noreferrer" target="_blank">바로보기</a>를 추천한다.</li><li>브라우저가 HTML을 해석하고 화면에 나타내는 방법은 표준을 따른다. 때로는, 같은 소스코드지만 브라우저마다 다른 결과를 볼 수 있는데, 브라우저에 따라 지원하는 스펙이 달라서 일어나는 현상이다.(<a href="https://caniuse.com/" rel="external nofollow noopener noreferrer" target="_blank">Can I Use</a>에서 확인 가능)</li></ul><h2 id="2-브라우저의-구조"><a href="#2-브라우저의-구조" class="headerlink" title="2. 브라우저의 구조"></a>2. 브라우저의 구조</h2><img src="/2018/06/06/browser-rendering/browser_structure.png" title="browser structure"><ul><li>UI : 주소창, 즐겨찾기 등 사용자가 조작 가능한 영역</li><li>브라우저 엔진 : UI와 렌더링 엔진 동작 제어</li><li><strong>렌더링 엔진 : 요청한 결과(응답)을 화면에 표시</strong></li><li>네트워킹 : HTTP 요청과 같은 네트워크 호출을 위해서 필요한 부분.</li><li>UI 백엔드 : OS 사용자 인터페이스 방법을 활용하여, 기본적인 위젯(콤보 박스등)을 그림</li><li>JS 엔진/인터프리터 : 자바스크립트를 해석하고 실행</li><li>데이터 저장소 : Local Storage, Indexed DB, 쿠키 등 브라우저 메모리를 활용하여 저장하는 영역 </li></ul><h2 id="3-주요-브라우저의-종류와-렌더링-엔진"><a href="#3-주요-브라우저의-종류와-렌더링-엔진" class="headerlink" title="3. 주요 브라우저의 종류와 렌더링 엔진"></a>3. 주요 브라우저의 종류와 렌더링 엔진</h2><table><thead><tr><th style="text-align:center">브라우저</th><th style="text-align:center">렌더링 엔진</th></tr></thead><tbody><tr><td style="text-align:center">IE</td><td style="text-align:center">Trident</td></tr><tr><td style="text-align:center">Chrome</td><td style="text-align:center">Webkit</td></tr><tr><td style="text-align:center">Safari</td><td style="text-align:center">Webkit</td></tr><tr><td style="text-align:center">FireFox</td><td style="text-align:center">Gecko</td></tr><tr><td style="text-align:center">Opera</td><td style="text-align:center">Presto</td></tr></tbody></table><hr><h1 id="브라우저의-렌더링-과정"><a href="#브라우저의-렌더링-과정" class="headerlink" title="브라우저의 렌더링 과정"></a>브라우저의 렌더링 과정</h1><h2 id="1-브라우저의-렌더링-엔진-요약"><a href="#1-브라우저의-렌더링-엔진-요약" class="headerlink" title="1. 브라우저의 렌더링 엔진 - 요약"></a>1. 브라우저의 렌더링 엔진 - 요약</h2><p>앞에서 살펴본 바와 같이, 브라우저의 렌더링 엔진은 서버로부터 받은 내용을 브라우저에 표시하는 역할을 한다.<br>다시 말해서, 서버로부터 받은 내용(HTML, CSS, Javascript ..등의 파일)을 변환해서 화면에 픽셀 단위로 나타내는 과정이다.</p><blockquote><ol><li>DOM(Document Object Model) 생성</li><li>CSSOM(CSS Object Model) 생성</li><li>Render Tree(=DOM + CSSOM) 생성</li><li>Render Tree 배치</li><li>Render Tree 그리기</li></ol></blockquote><p>위와 같이 다섯 단계를 거친다. 2번 CSSOM 생성 과정을 따로 분리하지 않고, 네 단계로 표현하기도 한다.</p><h2 id="2-렌더링-엔진-flow-chart"><a href="#2-렌더링-엔진-flow-chart" class="headerlink" title="2. 렌더링 엔진 flow chart"></a>2. 렌더링 엔진 flow chart</h2><p>Webkit과 Gecko 엔진에서는 이 과정을 각각 어떻게 처리하는 지 알아보겠다.</p><h3 id="Webkit-엔진에서-…"><a href="#Webkit-엔진에서-…" class="headerlink" title="Webkit 엔진에서 …"></a>Webkit 엔진에서 …</h3><img src="/2018/06/06/browser-rendering/webkit_flow.png" title="webkit render engine flow chart"><ol><li><p>DOM(Document Object Model) 생성</p><ul><li><p>다음 네 단계를 거쳐서, 트리 구조 모양의 DOM이 생성된다.</p><ol><li>Conversion(변환) : HTML의 raw bytes(원시 바이트)형태로 서버에서 받아온다. 해당 파일의 인코딩(예:UTF-8)에 따라 문자로 변환한다.</li><li>Tokenizing(토큰화) : 브라우저가 변환된 문자열을 HTML5 표준에 따라 고유 토큰으로 변환한다.</li><li>Lexing(렉싱) : 이 토큰들은 다시 각각의 특성과 규칙을 정의한 object(객체) “노드”로 변환된다.</li><li>DOM 생성 : HTML 마크업이 여러 태그 간의 관계를 나타내기 때문에 DOM은 트리 구조를 가진다. 따라서, DOM에 포함된 노드 또한 서로 관계성을 가지게 된다. 다시 말해서, 노드의 상대적인 관계를 이용하면, 하나의 노드를 기준으로 모든 노드에 접근할 수 있다. <a href="https://codepen.io/gooodev/pen/BVRdgy" rel="external nofollow noopener noreferrer" target="_blank">codepen참고</a></li></ol></li><li><p>DOM 트리는 문서 마크업의 속성과 관계를 포함하지만, 렌더링될 때 표시되는 모습에 대해서는 CSSOM이 관여한다.</p></li></ul></li><li><p>CSSOM(CSS Object Model) 생성</p><ul><li><p>1.에서 HTML에 했던 과정을 그대로 CSS에 반복한다. 그 결과로 브라우저가 이해하고 처리할 수 있는 형식(Style Rules)으로 변환된다.</p></li><li><p>CSSOM 역시 트리 구조를 가지는데, 그 이유는, ‘하향식’으로 규칙을 적용하기 때문이다. 루트(body)부터 시작해서, 트리를 만들어 가는 방식이다. 모든 요소의 최종 스타일을 확정할 때 브라우저는 해당 노드에 적용 가능한 가장 일반적인 규칙으로 시작한 후에 더욱 구체적인 규칙을 적용한다.</p></li></ul></li><li><p>Render Tree(=DOM + CSSOM) 생성 - Attachment</p><ul><li><p>DOM 트리의 루트(html)에서 시작해서, 페이지에 표시되는 각각의 노드에 일치하는 CSSOM 규칙을 찾아 붙인다.</p></li><li><p>이때, 렌더링 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함된다. 따라서, 메타 태그나 스크립트 태그 같은 노드나 <code>display : none</code> 으로 스타일이 지정된 노드는 제외된다. 그러나, <code>visibility : hidden</code> 스타일이 적용된 노드는 보이지는 않지만 공간을 차지하므로, 렌더링 트리에 포함된다.</p></li><li><p>이 렌더링 트리가 화면에서 최종적으로 그리는 내용이 된다.</p></li></ul></li><li><p>Render Tree 배치 - Layout</p><ul><li><p>지금까지의 과정을 요약하면, 브라우저가 화면에 표시할 노드와 해당 노드의 스타일을 계산하면서, 하나의 그룹으로 묶어서 렌더링 트리를 만든 것이다.</p></li><li><p>레이아웃은 브라우저가 화면에 그리기 전에, 이 노드들을 정확한 위치와 크기로 나타내기 위해서 계산하는 과정이다. 이때, 모든 상대적인 값(예:%단위)은 절대적인 값(예:px단위)로 변환된다.</p></li></ul></li><li><p>Render Tree 그리기 - Painting</p><ul><li>렌더링 트리의 각 노드를 화면의 픽셀로 나타내는 작업이다.</li></ul></li></ol><h3 id="Gecko-엔진에서-…"><a href="#Gecko-엔진에서-…" class="headerlink" title="Gecko 엔진에서 …"></a>Gecko 엔진에서 …</h3><p>언뜻 보면, 바로 전에 살펴본 Webkit 엔진 플로우 차트와 다른 점이 보인다. 그렇지만 자세히 살펴보면, 그 흐름은 비슷하다는 것을 알 수 있다.</p><img src="/2018/06/06/browser-rendering/gecko_flow.jpg" title="gecko render engine flow chart"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Webkit</th><th style="text-align:center">Gecko</th><th style="text-align:center">설명</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">없음.</td><td style="text-align:center">content sink</td><td style="text-align:center">DOM 노드를 만드는 공장</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Layout</td><td style="text-align:center">Reflow</td><td style="text-align:center">노드 배치</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Render Tree</td><td style="text-align:center">Frame Tree</td><td style="text-align:center">렌더링할 노드들의 묶음(그룹)</td></tr></tbody></table><h3 id="포스팅-예고"><a href="#포스팅-예고" class="headerlink" title="포스팅 예고"></a>포스팅 예고</h3><p>오늘 정리한 내용(브라우저 렌더링 과정)을 바탕으로, “렌더링 최적화 방법”에 대해서 쓰겠다.</p><ul><li>브라우저의 렌더링 엔진 - Deep Dive</li><li>브라우저의 성능을 저하시키는 방해 요소  </li><li>문제 해결 방법 : 최적화</li></ul><h3 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h3><ul><li>패스트캠퍼스 강의 : 장기효님의 “<a href="http://www.fastcampus.co.kr/dev_camp_wap/" rel="external nofollow noopener noreferrer" target="_blank">Vue로 구현하는 PWA 캠프</a>”</li><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_rendering_engines_threads" rel="external nofollow noopener noreferrer" target="_blank">How Browsers Work</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko" rel="external nofollow noopener noreferrer" target="_blank">구글 Web Fundamentals : Critical Rendering Path</a> </li><li><a href="https://d2.naver.com/helloworld/59361" rel="external nofollow noopener noreferrer" target="_blank">Naver D2 : 브라우저는 어떻게 동작하는가?</a></li></ul><!-- ### 첫 포스팅 소감새해에 새로운 사람으로 거듭나고자, 야심차게 만든 블로그 였지만, 2018년의 절반이 지나도록 포스팅을 1도 하지 못했다.(.. 아니 않았다. ㅠㅠ)지난 8주간 패스트캠퍼스에서 진행된, 장기효님의 “[Vue로 구현하는 PWA 캠프](http://www.fastcampus.co.kr/dev_camp_wap/)” 수업을 들으면서, 슬럼프에 빠져있던 내게 많은 동기 부여가 되었다.배운 내용을 복습하는 첫 포스팅을 시작으로, 부디 나 자신아, 부지런한 개발자가 되자. -->]]></content>
    
    <summary type="html">
    
      렌더링 최적화를 공부하기 전에, 브라우저가 어떤 역할을 하고, 렌더링 과정에서 어떤 일이 일어나는 지에 대해서 알아봅니다.
    
    </summary>
    
      <category term="프론트엔드 개발자라면 알아야할 것" scheme="http://janghanboram.github.io/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EA%B2%83/"/>
    
    
      <category term="브라우저 렌더링" scheme="http://janghanboram.github.io/tags/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81/"/>
    
      <category term="최적화" scheme="http://janghanboram.github.io/tags/%EC%B5%9C%EC%A0%81%ED%99%94/"/>
    
      <category term="FrontEnd" scheme="http://janghanboram.github.io/tags/FrontEnd/"/>
    
  </entry>
  
</feed>
